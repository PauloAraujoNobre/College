#include <stdio.h>
#include <stdlib.h>
#include <math.h>

void exibeAviso();

/* Métodos de manipulação de matrizes */

double **alocaMatriz(int n) {
    // Se houver memória disponível, aloca dinamicamente uma
    // matriz de double com n linhas e n+1 colunas e devolve um
    // ponteiro para essa matriz; caso contrário, devolve um
    // ponteiro nulo.
    int i, j;
    double **M;
    M = malloc(sizeof(double*) * n);
    if (M == NULL) // Falta de memória
        return NULL;
    for (i = 0; i < n; ++i) {
        M[i] = malloc(sizeof(double) * (n + 1));
        if (M[i] == NULL) { // Falta de memória
            for (j = 0; j < i; ++j)
                free(M[j]);
            free(M);
            return NULL;
        }
    }
    return M;
} /* Fim alocaMatriz */

void desalocaMatriz(double **M, int n) {
    // Libera a memória ocupada pela matriz
    // de double M de n linhas e n+1 colunas.
    int i;
    for (i = 0; i < n; ++i)
        free(M[i]);
    free(M);
} /* Fim desalocaMatriz */

void leMatriz(double **M, int n, FILE *f) {
    // Lê valores para uma matriz de double alocada
    // dinamicamente com n linhas e n+1 colunas.
    int i, j;
    double diag, somaLin = 0, somaCol = 0;
    for (i = 0; i < n; ++i){
        for (j = 0; j <= n; ++j){
            fscanf(f, "%lf", &M[i][j]);
        }
    }
} /* Fim leMatriz */


int verificaCriterios(double **M, int n) {
    // Lê valores para uma matriz de double alocada
    // dinamicamente com n linhas e n+1 colunas.
    int i, j, flagLin = 0, flagCol = 0, tipo = 0;
    double somaLin = 0, somaCol = 0, diag = 0;
    
    for (i = 0; i < n; i++){
        for (j = 0; j < n; j++){
            diag = abs(M[i][i]);

            if (j != i){
                somaLin += abs(M[i][j]);
                somaCol += abs(M[j][i]);
            }
        }

        if((somaLin / diag) > 1){
            flagLin = 1;
        }

        if((somaCol / diag) > 1){
            flagCol = 1;
        }

        somaLin = 0;
        somaCol = 0;
    }

    if(flagLin == 0 && flagCol == 0){
        printf("Nao houve criterios insastisfeitos\n\n");
        return tipo;
    }else{
        if(flagLin){
            printf("O criterio das linhas não foi sastisfeito\n");
            tipo++;
        }
        if(flagCol){
            printf("O criterio das colunas não foi sastisfeito\n\n");
            tipo++;
        }
        if(tipo == 2){
            printf("Os criterios n foram sastisfeitos, logo Gauss-Seidel nao ira convergir\n");
        }
        return tipo;
    }
}

 /* Fim leMatriz */

void exibeMatriz(double **M, int n) {
    // Imprime o conteúdo de uma matriz de double alocada
    // dinamicamente, com n linhas e n+1 colunas.
    int i, j;
    for (i = 0; i < n; ++i) {
        for (j = 0; j < n; ++j)
            printf("%10.3lf ", M[i][j]);
        printf("\n");
    }
} /* Fim exibeMatriz */

int resolveSLDiagonal(double **M, int n, double x[]) {
    // Recebe M, a matriz aumentada de um SL TS com n variáveis.
    // Se o SL for determinado, coloca em x a solução do sistema
    // linear e devolve 0. Se for indeterminado, coloca em x uma
    // solução do sistema linear e devolve 1. Caso contrário,
    // devolve 2.
    int i, j, tipo = 0;
    for (i = n - 1; i >= 0; i--) {
        if (M[i][i] == 0) {
            if (M[i][n] == 0) {
                x[i] = 0; // Variável livre
                tipo = 1;
            } else
                return 2; // SL incompatível
        } else
            x[i] = M[i][n] / M[i][i];
    }
    return tipo;
} /* Fim resolveSLDiagonal */

/* Opção C */

char *converteDecParaBase(double decimal, int base) {
    // Se houver memória disponível, retorna um
    // ponteiro para uma string contendo o número
    // decimal convertido para a base indicada
    // no parâmetro; caso contrário, retorna um
    // ponteiro nulo.
    const int tamanhoResposta = 50;
    const int maxCasasDecimais = 20;
    int i, j, pos = 0;
    int parteInteira = decimal;
    double parteFracionaria = decimal - parteInteira;
    char *resposta = malloc(sizeof(char) * (tamanhoResposta+1));
    if (!resposta)
        return NULL;

    // conversão da parte inteira
    int negativo = (decimal < 0);
    if (negativo) {
        resposta[pos++] = '-';
        parteInteira *= -1;
        parteFracionaria *= -1;
    }
    do {
        int resto = parteInteira % base;        
        char digito = (resto <= 9 ? '0' + resto : 'A' + resto - 10);
        resposta[pos++] = digito;
        parteInteira /= base;
    } while (parteInteira > 0 && pos < tamanhoResposta);

    for (i = negativo, j = pos - 1; i < j; ++i, --j) {
        char aux = resposta[i];
        resposta[i] = resposta[j];
        resposta[j] = aux;
    }

    // conversão da parte fracionária
    if (parteFracionaria != 0) {
        resposta[pos++] = '.';
        int tamanho = 0;
        while (parteFracionaria != 0 && tamanho < maxCasasDecimais && pos < tamanhoResposta) {
            parteFracionaria *= base;
            parteInteira = (int) parteFracionaria;
            char digito = (parteInteira <= 9 ? '0' + parteInteira : 'A' + parteInteira - 10);
            resposta[pos++] = digito;
            ++tamanho;
            if (parteFracionaria >= 1.0)
                parteFracionaria -= parteInteira;
        }
    }
    resposta[pos] = '\0';
    return resposta;
} /* Fim converteDecParaBase */

void converte() {
    // Exibe os números convertidos para as bases
    // binária, octal e hexadecimal.
    double decimal;
    int i, bases[] = { 2, 8, 16 };
    char *nomes[] = { "Binario", "Octal", "Hexadecimal" };
    char *resultado;
    printf("\nDigite o numero decimal a ser convertido");
    printf("\n(use ponto para numeros com parte fracionaria): ");
    scanf("%lf", &decimal);
    getchar();
    printf("\nDecimal: %lf\n", decimal);
    for (i = 0; i < 3; ++i) {
        resultado = converteDecParaBase(decimal, bases[i]);
        if (!resultado) {
            printf("Memoria insuficiente!\n");
            exibeAviso();
            return;
        }
        printf("%s: %s\n", nomes[i], resultado);
        free(resultado);
    }
    exibeAviso();
} /* Fim converte */

/* Opção S */

double novoResultado(double **M, double x[1000], int j, int i, int n){
    int a, k;
    double soma = 0;

    for (a = n-1, k = 1; a >= 0; a--){
        if (a != j){
            soma = soma + (M[j][(i-k)%n] * -x[i-k]);
            k++;
        }
    }

    soma = (soma + M[j][n]) / M[j][j];
    return soma;
}

void aplicaGaussSeidel(double **M, int n) {
    // Recebe M, a matriz aumentada de um SL com n variáveis
    // e n equações e transforma em uma matriz aumentada de
    // um SL diagonal equivalente.
    // /home/paulo/Desktop/SL
    int i, j, k, l, flag = 1;
    double x[100000] = {0};
    double aux;
    int a;
    i = n;
    int iteracoes = 1000;   
    while(iteracoes--){
        for (j = 0; j < n; j++){
            x[i] = novoResultado(M, x, j, i, n);
            i++;
        }
        for (k = i-n; k < n; k++){
            flag = 0;
            aux = x[k];
            if ((aux - ((int)aux)) > 0.000000009){
                flag = 1;
            }
        }
        if (!flag){
            iteracoes = 0;
        }
    }

    j = i - n;
    printf("Atraves do metodo de Gauss-Seidel:\n");
    for (l = 0; l < n; l++, j++){
        printf("x%d = %lf\n", l+1, x[j]);
    }
    
} /* Fim Gauss-Seidel */

void resolveSL() {
    // Resolve o sistema linear descrito no arquivo 
    // cujo nome for digitado.
    FILE *f;
    char nome[100];
    double **M, *x;
    int n, i, j, tipo;
    int criterio;
    printf("\nDigite o nome do arquivo de texto contendo o sistema linear: ");
    scanf("%s", nome);
    getchar();
    f = fopen(nome, "r");
    if (f == NULL) {
        printf("\nArquivo nao encontrado!\n");
        exibeAviso();
        return;
    }   
    fscanf(f, "%d", &n);
    M = alocaMatriz(n);
    x = malloc(sizeof(double) * n);
    if (M == NULL || x == NULL) {
        printf("Memoria insuficiente para alocar a matriz!\n");
        if (M != NULL)
            desalocaMatriz(M, n);
        if (x != NULL)
            free(x);
        return;
    }
    leMatriz(M, n, f);
    criterio = verificaCriterios(M, n);
    fclose(f);
    if (criterio != 2){
        aplicaGaussSeidel(M, n);
    }
    exibeAviso();
    desalocaMatriz(M, n);
    free(x);
} /* Fim resolveSL */

/* Opção E */

void aplicaLagrange(double *p, int n, int positivas, int negativas) {
    // Aplica o teorema de Lagrange ao polinômio p e exibe
    // os intervalos onde se encontram as raízes reais negativas
    // e as raízes reais positivas da equação.
    int i, j, k[4];
    int a0negativo = p[0] > 0.0 ? 1 : -1;
    int nImpar = (n & 1) ? -1 : 1;
    double L[4], B[4];
    // A primeira linha da matriz 'coeficientes' equivale a
    // p, a segunda a p1, a terceira a p2 e a quarta a p3.
    double coeficientes[4][n + 1];

    for (i = 0; i <= n; i++) {
        int indiceImpar = (i & 1) ? -1 : 1;
        coeficientes[0][i] = p[i];
        coeficientes[1][n - i] = p[i] * a0negativo;
        coeficientes[2][i] = p[i] * indiceImpar * nImpar;
        coeficientes[3][n - i] = -p[i] * indiceImpar * nImpar * a0negativo;
    }
    for (i = 0; i < 4; i++)
        k[i] = B[i] = -1;
    for (i = 0; i < 4; i++) {
        for (j = n; j >= 0; j--)
            if (coeficientes[i][j] < 0) {
                if (k[i] == -1)
                    k[i] = j;
                if (fabs(coeficientes[i][j]) > B[i])
                    B[i] = fabs(coeficientes[i][j]);
            }
        L[i] = 1 + pow((B[i] / coeficientes[i][n]), 1.0 / (n - k[i]));
    }
    printf("\nLimites para as raizes do polinomio:\n");
    if (positivas)
        printf("Positivas: %lf <= x+ <= %lf\n", 1.0 / L[1], L[0]);
    else
        printf("Nao ha raizes positivas para o polinomio.\n");
    if (negativas)
        printf("Negativas: %lf <= x- <= %lf\n", -L[2], -1.0 / L[3]);
    else
        printf("Nao ha raizes negativas para o polinomio.\n");
} /* Fim aplicaLagrange */

double aplicaBriotRuffini(double *p, int n, double c) {
    // Aplica o método de Briot-Ruffini no polinômio p
    // de grau n para calcular o valor de p no ponto c
    int i;
    double bi = p[n];
    for (i = n - 1; i >= 0; i--)
        bi = (bi * c + p[i]);
    return bi;
} /* Fim aplicaBriotRuffini */

void aplicaBissecao(double *p, int n, double a, double b) {
    // Aplica o método da bisseção no polinômio p de
    // grau n no intervalo [a, b] que possui uma quantidade
    // ímpar de raizes  e retorna um raiz de p nesse intervalo.
    const double epsilon = 1e-8;
    const int maxIteracoes = 1000;
    double m, fm, erro = 1, fa, fb;
    int i, achouExata = 0;
    fa = aplicaBriotRuffini(p, n, a);
    fb = aplicaBriotRuffini(p, n, b);
    for (i = 0; i < maxIteracoes && erro >= epsilon && !achouExata; i++) {
        erro = (b - a) / 2.0;
        m = (a + b) / 2.0;
        fm = aplicaBriotRuffini(p, n, m);
        if (fm == 0)
            achouExata = 1;
        else if (fa * fm < 0.0)
            b = m, fb = fm;
        else
            a = m, fa = fm;
    }
    printf("\nSolucao encontrada: %lf\n", m);
} /* Fim aplicaBissecao */

int aplicaBolzano(double *p, int n, double a, double b) {
    // Aplica o teorema de Bolzano no polinômio p de grau n.
    // Se há uma quantidade ímpar de raizes no intervalo [a, b],
    // retorna 1; se a ou b forem raizes de p, avisa ao usuário
    // e retorna 0; caso contrário avisa ao usuário que há uma
    // quantidade par de raizes no intervalo [a, b] e retorna 0.
    double fa, fb;
    fa = aplicaBriotRuffini(p, n, a);
    fb = aplicaBriotRuffini(p, n, b);

    if (fa * fb < 0)
        return 1;
    else if (fa * fb > 0)
        printf("Numero de raizes eh par no intervalo [%lf, %lf]\n", a, b);
    else
        printf("%lf eh uma raiz do polinomio\n", fa == 0 ? a : b);
    return 0;
} /* Fim aplicaBolzano */

int *calculaVariacoesEPermanencias(double *p, int n) {
    // Recebe p, o vetor de coeficientes de um
    // polinômio, e n, o grau de p. Se houver
    // memória disponível, retorna um ponteiro
    // para um vetor com o número de variações
    // e de permanências de sinal de p. Caso
    // contrário, retorna um ponteiro nulo.
    int variacoes = 0, permanencias = 0, i;
    int sinal = p[0] > 0 ? 1 : -1;
    int *resultado = malloc(sizeof(int) * 2);
    if (!resultado)
        return NULL;
    for (i = 1; i <= n; i++)
        if (p[i] != 0) {
            int atual = p[i] > 0 ? 1 : -1;
            if (sinal != atual)
                variacoes++;
            else
                permanencias++;
            sinal = atual;
        }
    resultado[0] = variacoes;
    resultado[1] = permanencias;
    return resultado;
} /* Fim calculaVariacoesEPermanencias */

void resolveEquacao() {
    // Rescebe um polinômio como entrada, aplica o teorema de Lagrange,
    // e, se possível, aplica o método da bisseção em um intervalo
    // indicado pela entrada.
    int n, i, raizesImpares;
    double *p, a, b, aux;
    printf("\nQual o grau do polinomio? ");
    scanf("%d", &n);
    if (n < 1) {
        printf("\nO grau do polinomio deve ser pelo menos 1!\n");
        getchar();
        exibeAviso();
        return;
    }
    p = malloc(sizeof(double) * (n + 1));
    if (p == NULL) {
        printf("\nMemoria insuficiente para alocar os coeficientes!\n");
        exibeAviso();
        return;
    }
    printf("\nDigite os coeficientes a partir de an ate a0: ");
    for (i = n; i >= 0; i--)
        scanf("%lf", &p[i]);
    if (p[n] <= 0.0) {
        printf("\nan deve ser maior do que zero!\n");
        getchar();
        exibeAviso();
        return;
    } else if (p[0] == 0.0) {
        printf("\na0 deve ser diferente de zero!\n");
        getchar();
        exibeAviso();
        return;
    }
    int *variacoesEPermanencias = calculaVariacoesEPermanencias(p, n);
    if (!variacoesEPermanencias) {
        printf("\nMemoria insuficiente!\n");
        exibeAviso();
        return;
    }
    int var = variacoesEPermanencias[0];
    int per = variacoesEPermanencias[1];
    aplicaLagrange(p, n, var, per);
    printf("\nDigite o comeco e o fim do intervalo a ser\nprocurado (separado por um espaco): ");
    scanf("%lf %lf", &a, &b);
    getchar();
    if (a > b) {
        aux = b;
        b = a;
        a = aux;
    }
    raizesImpares = aplicaBolzano(p, n, a, b);
    if (raizesImpares)
        aplicaBissecao(p, n, a, b);
    exibeAviso();
    free(variacoesEPermanencias);
    free(p);
} /* Fim resolveEquacao */

/* Métodos de interface */

void exibeAviso() {
    // Mantém mensagem na tela até que o usuário aperte ENTER.
    printf("\nAperte ENTER para voltar para o menu\n");
    getchar();
} /* Fim exibeAviso */

int trataEntrada() {
    // Invoca o método correspondente à letra digitada
    // pelo usuário no menu. Caso a entrada seja
    // inválida, o usuário é alertado.
    char opcao = getchar();

    switch(opcao) {
        case 'C':
        case 'c':
            converte();
            break;
        case 'S':
        case 's':
            resolveSL();
            break;
        case 'E':
        case 'e':
            resolveEquacao();
            break;
        case 'F':
        case 'f':
            return 0;
        default:
            getchar();
            printf("\n\n Opcao invalida!\n");
            exibeAviso();
    }
    return 1;
} /* Fim trataEntrada */

void exibeMenu() {
    // Apresenta as opções do menu.
    printf("\n\nMenu\n\n");
    printf("C - Conversao\n");
    printf("S - Sistema Linear\n");
    printf("E – Equacao Algebrica\n");
    printf("F – Finalizar\n\n");
    printf("Escolha uma das opcoes acima digitando a letra correspondente: ");
} /* Fim exibeMenu */

int main() {
    // Executa o programa em loop, aguardando uma
    // nova entrada enquanto o usuário não encerra
    // o aplicativo.
    do {
        exibeMenu();
    } while (trataEntrada());
    return 0;
} /* Fim main */
